// Package ovndb provides OVN database client operations.
//
// This package wraps the libovsdb library to provide type-safe
// operations on OVN Northbound and Southbound databases.
//
// OVN Database Structure:
// - Northbound DB (NB DB): High-level network configuration
//   - Logical_Switch: Virtual L2 network (corresponds to a subnet)
//   - Logical_Router: Virtual L3 router (provides routing between subnets)
//   - Logical_Switch_Port: Port on a logical switch (represents a Pod's network interface)
//   - Load_Balancer: L4 load balancer (implements Kubernetes Service)
//   - ACL: Access control list (implements NetworkPolicy)
//
// - Southbound DB (SB DB): Low-level flow tables
//   - Chassis: Physical node information (represents a Kubernetes node)
//   - Port_Binding: Port to chassis binding (maps LSP to physical node)
//   - Logical_Flow: Compiled flow rules (generated by northd)
//
// Connection Modes:
// - TCP: Plain text connection (tcp:IP:PORT)
// - SSL: Encrypted connection with certificates (ssl:IP:PORT)
//
// Reference: OVN-Kubernetes pkg/libovsdb/
package ovndb

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/cenkalti/backoff/v4"
	"github.com/ovn-org/libovsdb/client"
	"github.com/ovn-org/libovsdb/model"
	"k8s.io/klog/v2"
)

// Default timeout and retry configuration
const (
	// DefaultConnectTimeout is the default timeout for initial connection
	DefaultConnectTimeout = 30 * time.Second

	// DefaultReconnectInterval is the initial interval between reconnection attempts
	DefaultReconnectInterval = 1 * time.Second

	// DefaultMaxReconnectInterval is the maximum interval between reconnection attempts
	// Used for exponential backoff (1s, 2s, 4s, 8s, ..., max 60s)
	DefaultMaxReconnectInterval = 60 * time.Second

	// DefaultInactivityTimeout is the timeout for detecting inactive connections
	DefaultInactivityTimeout = 180 * time.Second

	// DefaultTxnTimeout is the default timeout for database transactions
	DefaultTxnTimeout = 30 * time.Second
)

// Client is the OVN database client
// It provides operations on both NB DB and SB DB
//
// The client supports two connection modes:
// - TCP: Plain text connection for development/testing
// - SSL: Encrypted connection for production environments
//
// Connection lifecycle:
// 1. Create client with NewClient()
// 2. Connect to databases with Connect()
// 3. Perform operations (CreateLogicalSwitch, etc.)
// 4. Close connections with Close()
type Client struct {
	// nbClient is the Northbound DB client
	// NB DB stores high-level network configuration
	nbClient client.Client

	// sbClient is the Southbound DB client
	// SB DB stores compiled flow tables and chassis info
	sbClient client.Client

	// config is the client configuration
	config *ClientConfig

	// mu protects concurrent access to client state
	mu sync.RWMutex

	// connected indicates if the client is connected
	connected bool

	// stopCh is used to signal shutdown
	stopCh chan struct{}
}

// ClientConfig is the OVN client configuration
type ClientConfig struct {
	// NBDBAddress is the Northbound DB address
	// Format: tcp:IP:PORT or ssl:IP:PORT
	// Example: "tcp:192.168.1.100:6641" or "ssl:192.168.1.100:6641"
	// Multiple addresses can be specified separated by commas for HA
	NBDBAddress string

	// SBDBAddress is the Southbound DB address
	// Format: tcp:IP:PORT or ssl:IP:PORT
	// Example: "tcp:192.168.1.100:6642" or "ssl:192.168.1.100:6642"
	SBDBAddress string

	// SSL is the SSL configuration (optional)
	// Required when using ssl: scheme in addresses
	SSL *SSLConfig

	// ConnectTimeout is the connection timeout
	// Default: 30 seconds
	ConnectTimeout time.Duration

	// ReconnectInterval is the initial reconnect interval
	// Default: 1 second
	ReconnectInterval time.Duration

	// MaxReconnectInterval is the maximum reconnect interval (for exponential backoff)
	// Default: 60 seconds
	MaxReconnectInterval time.Duration

	// TxnTimeout is the timeout for database transactions
	// Default: 30 seconds
	TxnTimeout time.Duration
}

// SSLConfig is the SSL connection configuration
// All paths must point to PEM-encoded files
type SSLConfig struct {
	// CACert is the CA certificate path
	// Used to verify the server's certificate
	CACert string

	// ClientCert is the client certificate path
	// Used for client authentication
	ClientCert string

	// ClientKey is the client private key path
	// Must match the client certificate
	ClientKey string

	// ServerName is the expected server name for certificate verification
	// If empty, the hostname from the address is used
	ServerName string
}

// NewClient creates a new OVN client
//
// Parameters:
//   - config: Client configuration including database addresses and SSL settings
//
// Returns:
//   - *Client: OVN client instance (not yet connected)
//   - error: Configuration validation error
//
// Example:
//
//	config := &ClientConfig{
//	    NBDBAddress: "tcp:192.168.1.100:6641",
//	    SBDBAddress: "tcp:192.168.1.100:6642",
//	}
//	client, err := NewClient(config)
//	if err != nil {
//	    return err
//	}
//	defer client.Close()
//	if err := client.Connect(ctx); err != nil {
//	    return err
//	}
func NewClient(config *ClientConfig) (*Client, error) {
	if config == nil {
		return nil, fmt.Errorf("config is required")
	}

	if config.NBDBAddress == "" {
		return nil, fmt.Errorf("NBDBAddress is required")
	}

	// Apply default values
	if config.ConnectTimeout == 0 {
		config.ConnectTimeout = DefaultConnectTimeout
	}
	if config.ReconnectInterval == 0 {
		config.ReconnectInterval = DefaultReconnectInterval
	}
	if config.MaxReconnectInterval == 0 {
		config.MaxReconnectInterval = DefaultMaxReconnectInterval
	}
	if config.TxnTimeout == 0 {
		config.TxnTimeout = DefaultTxnTimeout
	}

	// Validate SSL config if using SSL scheme
	if strings.HasPrefix(config.NBDBAddress, "ssl:") || strings.HasPrefix(config.SBDBAddress, "ssl:") {
		if config.SSL == nil {
			return nil, fmt.Errorf("SSL configuration is required when using ssl: scheme")
		}
		if config.SSL.CACert == "" || config.SSL.ClientCert == "" || config.SSL.ClientKey == "" {
			return nil, fmt.Errorf("SSL configuration requires CACert, ClientCert, and ClientKey")
		}
	}

	c := &Client{
		config: config,
		stopCh: make(chan struct{}),
	}

	return c, nil
}

// Connect establishes connection to OVN databases with exponential backoff retry
//
// This method will:
// 1. Create database model for NB DB
// 2. Connect to NB DB with retry
// 3. Optionally connect to SB DB if address is provided
//
// The connection uses exponential backoff retry:
// - Initial interval: config.ReconnectInterval (default 1s)
// - Max interval: config.MaxReconnectInterval (default 60s)
// - Multiplier: 2 (1s, 2s, 4s, 8s, 16s, 32s, 60s, 60s, ...)
//
// Parameters:
//   - ctx: Context for cancellation
//
// Returns:
//   - error: Connection error after all retries exhausted
func (c *Client) Connect(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.connected {
		return nil
	}

	// Connect to NB DB
	nbClient, err := c.connectWithRetry(ctx, c.config.NBDBAddress, "OVN_Northbound")
	if err != nil {
		return fmt.Errorf("failed to connect to NB DB at %s: %w", c.config.NBDBAddress, err)
	}
	c.nbClient = nbClient

	// Connect to SB DB if address is provided
	if c.config.SBDBAddress != "" {
		sbClient, err := c.connectWithRetry(ctx, c.config.SBDBAddress, "OVN_Southbound")
		if err != nil {
			// Close NB client if SB connection fails
			c.nbClient.Close()
			c.nbClient = nil
			return fmt.Errorf("failed to connect to SB DB at %s: %w", c.config.SBDBAddress, err)
		}
		c.sbClient = sbClient
	}

	c.connected = true
	klog.Infof("Successfully connected to OVN databases")
	return nil
}

// connectWithRetry connects to a single OVN database with exponential backoff
func (c *Client) connectWithRetry(ctx context.Context, address, dbName string) (client.Client, error) {
	// Create exponential backoff
	expBackoff := backoff.NewExponentialBackOff()
	expBackoff.InitialInterval = c.config.ReconnectInterval
	expBackoff.MaxInterval = c.config.MaxReconnectInterval
	expBackoff.MaxElapsedTime = 0 // No max elapsed time, rely on context

	var dbClient client.Client
	var lastErr error

	operation := func() error {
		select {
		case <-ctx.Done():
			return backoff.Permanent(ctx.Err())
		case <-c.stopCh:
			return backoff.Permanent(fmt.Errorf("client is closing"))
		default:
		}

		var err error
		dbClient, err = c.createClient(address, dbName)
		if err != nil {
			lastErr = err
			klog.V(4).Infof("Failed to connect to %s at %s: %v, retrying...", dbName, address, err)
			return err
		}

		// Try to connect
		connectCtx, cancel := context.WithTimeout(ctx, c.config.ConnectTimeout)
		defer cancel()

		if err := dbClient.Connect(connectCtx); err != nil {
			lastErr = err
			klog.V(4).Infof("Failed to connect to %s at %s: %v, retrying...", dbName, address, err)
			return err
		}

		return nil
	}

	// Create a context-aware backoff
	backoffCtx := backoff.WithContext(expBackoff, ctx)

	if err := backoff.Retry(operation, backoffCtx); err != nil {
		if lastErr != nil {
			return nil, lastErr
		}
		return nil, err
	}

	klog.Infof("Connected to %s at %s", dbName, address)
	return dbClient, nil
}

// createClient creates a libovsdb client for the given address
func (c *Client) createClient(address, dbName string) (client.Client, error) {
	// Build client options
	options := []client.Option{
		client.WithLeaderOnly(true),
		client.WithInactivityCheck(DefaultInactivityTimeout, c.config.ConnectTimeout, &backoff.ZeroBackOff{}),
	}

	// Parse endpoints (support multiple addresses for HA)
	for _, endpoint := range strings.Split(address, ",") {
		endpoint = strings.TrimSpace(endpoint)
		if endpoint != "" {
			options = append(options, client.WithEndpoint(endpoint))
		}
	}

	// Add SSL configuration if needed
	if strings.HasPrefix(address, "ssl:") && c.config.SSL != nil {
		tlsConfig, err := c.createTLSConfig()
		if err != nil {
			return nil, fmt.Errorf("failed to create TLS config: %w", err)
		}
		options = append(options, client.WithTLSConfig(tlsConfig))
	}

	// Create database model based on database name
	dbModel, err := c.createDBModel(dbName)
	if err != nil {
		return nil, fmt.Errorf("failed to create database model for %s: %w", dbName, err)
	}

	return client.NewOVSDBClient(dbModel, options...)
}

// createDBModel creates the database model for the given database name
func (c *Client) createDBModel(dbName string) (model.ClientDBModel, error) {
	switch dbName {
	case "OVN_Northbound":
		return NBDBModel()
	case "OVN_Southbound":
		return SBDBModel()
	default:
		return model.ClientDBModel{}, fmt.Errorf("unknown database: %s", dbName)
	}
}

// createTLSConfig creates TLS configuration from SSL config
func (c *Client) createTLSConfig() (*tls.Config, error) {
	if c.config.SSL == nil {
		return nil, fmt.Errorf("SSL config is nil")
	}

	// Load client certificate and key
	cert, err := tls.LoadX509KeyPair(c.config.SSL.ClientCert, c.config.SSL.ClientKey)
	if err != nil {
		return nil, fmt.Errorf("failed to load client certificate: %w", err)
	}

	// Load CA certificate
	caCert, err := os.ReadFile(c.config.SSL.CACert)
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %w", err)
	}

	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to parse CA certificate")
	}

	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      caCertPool,
		MinVersion:   tls.VersionTLS12,
	}

	if c.config.SSL.ServerName != "" {
		tlsConfig.ServerName = c.config.SSL.ServerName
	}

	return tlsConfig, nil
}

// Close closes the OVN database connections
func (c *Client) Close() {
	c.mu.Lock()
	defer c.mu.Unlock()

	// Signal shutdown
	select {
	case <-c.stopCh:
		// Already closed
	default:
		close(c.stopCh)
	}

	if c.nbClient != nil {
		c.nbClient.Close()
		c.nbClient = nil
	}

	if c.sbClient != nil {
		c.sbClient.Close()
		c.sbClient = nil
	}

	c.connected = false
	klog.Infof("OVN database connections closed")
}

// IsConnected returns whether the client is connected
func (c *Client) IsConnected() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.connected
}

// NBClient returns the Northbound DB client
// Returns nil if not connected
func (c *Client) NBClient() client.Client {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.nbClient
}

// SBClient returns the Southbound DB client
// Returns nil if not connected or SB DB address not configured
func (c *Client) SBClient() client.Client {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.sbClient
}

// GetTxnTimeout returns the transaction timeout
func (c *Client) GetTxnTimeout() time.Duration {
	return c.config.TxnTimeout
}
